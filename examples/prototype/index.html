<!doctype html>
<html lang="en">
    <head>
        <meta charset="UTF-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1.0" />
        <meta http-equiv="Cache-Control" content="no-cache, no-store, must-revalidate" />
        <meta http-equiv="Pragma" content="no-cache" />
        <meta http-equiv="Expires" content="0" />
        <title>EngineKernel 原型验证</title>
        <link rel="stylesheet" href="./index.css " />
        
        <!-- 使用本地 THREE.js 文件的 import map -->
        <script type="importmap">
        {
            "imports": {
                "three": "./libs/three.module.js",
                "three/examples/jsm/controls/OrbitControls.js": "./libs/OrbitControls.js",
                "three/examples/jsm/loaders/GLTFLoader.js": "./libs/GLTFLoader.js",
                "three/examples/jsm/renderers/CSS3DRenderer.js": "./libs/CSS3DRenderer.js",
                "three/examples/jsm/objects/Sky.js": "./libs/Sky.js"
            }
        }
        </script>
    </head>
    <body>
        <canvas id="container"></canvas>
        
        <script type="module">
            // 使用本地 THREE.js 文件
            import * as THREE from 'three';
            import { OrbitControls } from 'three/examples/jsm/controls/OrbitControls.js';
            import { GLTFLoader } from 'three/examples/jsm/loaders/GLTFLoader.js';
            import { CSS3DRenderer, CSS3DObject } from 'three/examples/jsm/renderers/CSS3DRenderer.js';
            import { Sky } from 'three/examples/jsm/objects/Sky.js';
            
            // 将模块挂载到全局，以供我们的 UMD 包使用
            window.THREE = THREE;
            // 由于 THREE 对象不可扩展，我们直接挂载到 window
            window.OrbitControls = OrbitControls;
            window.GLTFLoader = GLTFLoader;
            window.CSS3DRenderer = CSS3DRenderer;
            window.CSS3DObject = CSS3DObject;
            window.Sky = Sky;
            
            console.log('THREE.js 模块已加载:', THREE);
            console.log('OrbitControls 已加载:', OrbitControls);
            console.log('CSS3DRenderer 已加载:', CSS3DRenderer);
            console.log('CSS3DObject 已加载:', CSS3DObject);
            console.log('所有模块已从本地文件加载完成');
            
            // 动态加载我们的 EngineKernel
            const script = document.createElement('script');
            script.src = 'http://localhost:8080/engine-kernel.dev.js';
            script.onload = function() {
                // 等待一下，确保模块完全加载
                setTimeout(() => {
                    if (typeof window.EngineKernel !== 'undefined' && window.EngineKernel.constructor !== Promise) {
                        console.log("🚀 ~ EngineKernel 加载成功:", window.EngineKernel);
                        loadMainScript();
                    } else if (window.EngineKernel && typeof window.EngineKernel.then === 'function') {
                        window.EngineKernel.then(engine => {
                            window.EngineKernel = engine;
                            console.log("🚀 ~ EngineKernel 异步加载成功:", window.EngineKernel);
                            loadMainScript();
                        });
                    } else {
                        console.error('EngineKernel 模块加载失败');
                    }
                }, 100);
            };
            script.onerror = function() {
                console.error('无法加载 EngineKernel 脚本');
            };
            document.head.appendChild(script);

            function loadMainScript() {
                // 动态加载主要逻辑
                const mainScript = document.createElement('script');
                mainScript.src = './index.js';
                document.body.appendChild(mainScript);
            }
        </script>
    </body>
</html>
<!-- 

后续计划

- [ ] 让loadPlugin、unloadPlugin、方法发挥作用

- [ ] 安排插件加载策略（搞清楚是注册还是加载，这两者的职责和先后顺序搞清楚，插件的加载策略是同步还是异步？
在同步加载的插件和异步加载的插件同时存在的情况应该如何处理，加载顺序、加载策略会不会影响依赖关系？）

- [ ] 插件的依赖关系，比如控制器插件就依赖于渲染器插件提供的dom和基础场景插件baseScene提供的camera，
所以控制器插件在加载/注册之前就必须要拿到baseScene和渲染器插件的实例

- [ ] 后续功能的添加（特效模块、楼栋分层、）

- [ ] 鼠标拾取暂时用光线拾取、后续添加GPU拾取

- [ ] 搞清楚笛卡尔坐标系在具体中的应用

- [ ] 可否实现架构与插件相分离？（需要一个稳定的架构，然后安心开发插件就行了）

- [ ] 限定事件类型（所有事件类型的枚举）

- [ ] 可以将事件发布订阅机制包装好然后由core核心模块继承，更好的实现插件生命周期管理与插件通信特性

- [ ] 探究路径规划方法（场景中随机选取的两点之间的最优路径，并且能够绕过墙壁、通过楼梯电梯、）

- [ ] 科技感地板特效+天空盒（贴图或shader）

- [ ] 需要搞懂：

- [ ] html转3D对象：目前threejs示例给出的例子不好

-->
